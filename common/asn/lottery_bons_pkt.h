//   NOTE: this is a machine generated file--editing not recommended
//
// lottery_bons_pkt.h - class definitions for ASN.1 module LOTTERYBONSMESSAGE
//
//   This file was generated by snacc on Thu Dec 11 21:06:26 2014
//   UBC snacc by Mike Sample
//   A couple of enhancements made by IBM European Networking Center

#ifndef _lottery_bons_pkt_h_
#define _lottery_bons_pkt_h_


//------------------------------------------------------------------------------
// class declarations:

namespace NS_LotteryBons {

class LBNameValue;
class LBNameValueList;
class TASK;
class TASKList;
class ReqLBMasterHeartBeat;
class RspLBMasterHeartBeat;
class ReqLBMasterAddTask;
class RspLBMasterAddTask;
class ReqLBMasterDoTask;
class RspLBMasterDoTask;
class ReqLBWorkerHeartBeat;
class RspLBWorkerHeartBeat;
class ReqLBWorkerQueryTask;
class RspLBWorkerQueryTask;
class ReqLBWorkerSetTask;
class RspLBWorkerSetTask;
class ReqLBWorkerStopTask;
class RspLBWorkerStopTask;
class BODYPKTS;
class LotteryBonsMessage;
class LBStringList;

//------------------------------------------------------------------------------
// class definitions:

class LBNameValue: public AsnType
{
public:
  AsnOcts		name;
  AsnOcts		value;

			LBNameValue();
			LBNameValue (const LBNameValue &);
			~LBNameValue();
  AsnType		*Clone() const;

  LBNameValue		&operator = (const LBNameValue &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class LBNameValueList: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    LBNameValue	*elmt;
  }			*first, *curr, *last;

public:
			LBNameValueList() { count = 0; first = curr = last = NULL; }
			LBNameValueList (const LBNameValueList &);
			~LBNameValueList();
  AsnType		*Clone() const;

  LBNameValueList		&operator = (const LBNameValueList &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  LBNameValue	*First() const	{ return count > 0 ? first->elmt : NULL; }
  LBNameValue	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  LBNameValue	*Curr() const	{ return curr ? curr->elmt : NULL; }
  LBNameValue	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  LBNameValue	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  LBNameValue	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  LBNameValue	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  LBNameValue	*Append();  // add elmt to end of list
  LBNameValue	*Prepend(); // add elmt to beginning of list
  LBNameValue	*InsertBefore(); //insert elmt before current elmt
  LBNameValue	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  LBNameValueList	&AppendCopy (LBNameValue &elmt);  // add elmt to end of list
  LBNameValueList	&PrependCopy (LBNameValue &elmt); // add elmt to beginning of list
  LBNameValueList	&InsertBeforeAndCopy (LBNameValue &elmt); //insert elmt before current elmt
  LBNameValueList	&InsertAfterAndCopy (LBNameValue &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class TASK: public AsnType
{
public:
  AsnInt		taskID;
  AsnInt		taskType;
  AsnInt		taskState;
  AsnOcts		lotteryName;
  AsnOcts		lotteryPlay;
  AsnOcts		conditionSql;
  AsnInt		qihaoBegin;
  AsnInt		qihaoEnd;
  AsnInt		projectBegin;
  AsnInt		projectEnd;
  AsnInt		fracMod;
  AsnInt		denoMod;
  AsnInt		isUpdateDB;
  AsnInt		isUpdateFile;
  AsnInt		isForceRecompute;
  AsnInt		isEarlyPayBonus;
  AsnInt		iReserve1;
  AsnInt		iReserve2;
  AsnOcts		strReserve1;
  AsnOcts		strReserve2;
  LBNameValueList		reserve;

			TASK();
			TASK (const TASK &);
			~TASK();
  AsnType		*Clone() const;

  TASK		&operator = (const TASK &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class TASKList: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    TASK	*elmt;
  }			*first, *curr, *last;

public:
			TASKList() { count = 0; first = curr = last = NULL; }
			TASKList (const TASKList &);
			~TASKList();
  AsnType		*Clone() const;

  TASKList		&operator = (const TASKList &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  TASK	*First() const	{ return count > 0 ? first->elmt : NULL; }
  TASK	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  TASK	*Curr() const	{ return curr ? curr->elmt : NULL; }
  TASK	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  TASK	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  TASK	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  TASK	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  TASK	*Append();  // add elmt to end of list
  TASK	*Prepend(); // add elmt to beginning of list
  TASK	*InsertBefore(); //insert elmt before current elmt
  TASK	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  TASKList	&AppendCopy (TASK &elmt);  // add elmt to end of list
  TASKList	&PrependCopy (TASK &elmt); // add elmt to beginning of list
  TASKList	&InsertBeforeAndCopy (TASK &elmt); //insert elmt before current elmt
  TASKList	&InsertAfterAndCopy (TASK &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class ReqLBMasterHeartBeat: public AsnType
{
public:
  AsnInt		hbMod;
  LBNameValueList		reserve;

			ReqLBMasterHeartBeat();
			ReqLBMasterHeartBeat (const ReqLBMasterHeartBeat &);
			~ReqLBMasterHeartBeat();
  AsnType		*Clone() const;

  ReqLBMasterHeartBeat		&operator = (const ReqLBMasterHeartBeat &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class RspLBMasterHeartBeat: public AsnType
{
public:
  AsnInt		retCode;
  LBNameValueList		svrInfo;

			RspLBMasterHeartBeat();
			RspLBMasterHeartBeat (const RspLBMasterHeartBeat &);
			~RspLBMasterHeartBeat();
  AsnType		*Clone() const;

  RspLBMasterHeartBeat		&operator = (const RspLBMasterHeartBeat &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class ReqLBMasterAddTask: public AsnType
{
public:
  TASKList		tasks;
  LBNameValueList		reserve;

			ReqLBMasterAddTask();
			ReqLBMasterAddTask (const ReqLBMasterAddTask &);
			~ReqLBMasterAddTask();
  AsnType		*Clone() const;

  ReqLBMasterAddTask		&operator = (const ReqLBMasterAddTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class RspLBMasterAddTask: public AsnType
{
public:
  AsnInt		retCode;
  LBNameValueList		reserve;

			RspLBMasterAddTask();
			RspLBMasterAddTask (const RspLBMasterAddTask &);
			~RspLBMasterAddTask();
  AsnType		*Clone() const;

  RspLBMasterAddTask		&operator = (const RspLBMasterAddTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class ReqLBMasterDoTask: public AsnType
{
public:
  TASKList		tasks;
  LBNameValueList		reserve;

			ReqLBMasterDoTask();
			ReqLBMasterDoTask (const ReqLBMasterDoTask &);
			~ReqLBMasterDoTask();
  AsnType		*Clone() const;

  ReqLBMasterDoTask		&operator = (const ReqLBMasterDoTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class RspLBMasterDoTask: public AsnType
{
public:
  AsnInt		retCode;
  LBNameValueList		reserve;

			RspLBMasterDoTask();
			RspLBMasterDoTask (const RspLBMasterDoTask &);
			~RspLBMasterDoTask();
  AsnType		*Clone() const;

  RspLBMasterDoTask		&operator = (const RspLBMasterDoTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class ReqLBWorkerHeartBeat: public AsnType
{
public:
  AsnInt		hbMod;
  LBNameValueList		reserve;

			ReqLBWorkerHeartBeat();
			ReqLBWorkerHeartBeat (const ReqLBWorkerHeartBeat &);
			~ReqLBWorkerHeartBeat();
  AsnType		*Clone() const;

  ReqLBWorkerHeartBeat		&operator = (const ReqLBWorkerHeartBeat &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class RspLBWorkerHeartBeat: public AsnType
{
public:
  AsnInt		retCode;
  LBNameValueList		svrInfo;

			RspLBWorkerHeartBeat();
			RspLBWorkerHeartBeat (const RspLBWorkerHeartBeat &);
			~RspLBWorkerHeartBeat();
  AsnType		*Clone() const;

  RspLBWorkerHeartBeat		&operator = (const RspLBWorkerHeartBeat &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class ReqLBWorkerQueryTask: public AsnType
{
public:
  LBNameValueList		reserve;

			ReqLBWorkerQueryTask();
			ReqLBWorkerQueryTask (const ReqLBWorkerQueryTask &);
			~ReqLBWorkerQueryTask();
  AsnType		*Clone() const;

  ReqLBWorkerQueryTask		&operator = (const ReqLBWorkerQueryTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class RspLBWorkerQueryTask: public AsnType
{
public:
  AsnInt		retCode;
  TASK		*taskInfo;
  LBNameValueList		reserve;

			RspLBWorkerQueryTask();
			RspLBWorkerQueryTask (const RspLBWorkerQueryTask &);
			~RspLBWorkerQueryTask();
  AsnType		*Clone() const;

  RspLBWorkerQueryTask		&operator = (const RspLBWorkerQueryTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class ReqLBWorkerSetTask: public AsnType
{
public:
  TASK		*taskInfo;
  LBNameValueList		reserve;

			ReqLBWorkerSetTask();
			ReqLBWorkerSetTask (const ReqLBWorkerSetTask &);
			~ReqLBWorkerSetTask();
  AsnType		*Clone() const;

  ReqLBWorkerSetTask		&operator = (const ReqLBWorkerSetTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class RspLBWorkerSetTask: public AsnType
{
public:
  AsnInt		retCode;
  LBNameValueList		reserve;

			RspLBWorkerSetTask();
			RspLBWorkerSetTask (const RspLBWorkerSetTask &);
			~RspLBWorkerSetTask();
  AsnType		*Clone() const;

  RspLBWorkerSetTask		&operator = (const RspLBWorkerSetTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class ReqLBWorkerStopTask: public AsnType
{
public:
  TASK		*taskInfo;
  LBNameValueList		reserve;

			ReqLBWorkerStopTask();
			ReqLBWorkerStopTask (const ReqLBWorkerStopTask &);
			~ReqLBWorkerStopTask();
  AsnType		*Clone() const;

  ReqLBWorkerStopTask		&operator = (const ReqLBWorkerStopTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class RspLBWorkerStopTask: public AsnType
{
public:
  AsnInt		retCode;
  LBNameValueList		reserve;

			RspLBWorkerStopTask();
			RspLBWorkerStopTask (const RspLBWorkerStopTask &);
			~RspLBWorkerStopTask();
  AsnType		*Clone() const;

  RspLBWorkerStopTask		&operator = (const RspLBWorkerStopTask &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class BODYPKTS: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     reqLBMasterHeartBeatCid = 0,
     rspLBMasterHeartBeatCid = 1,
     reqLBMasterAddTaskCid = 2,
     rspLBMasterAddTaskCid = 3,
     reqLBMasterDoTaskCid = 4,
     rspLBMasterDoTaskCid = 5,
     reqLBWorkerHeartBeatCid = 6,
     rspLBWorkerHeartBeatCid = 7,
     reqLBWorkerQueryTaskCid = 8,
     rspLBWorkerQueryTaskCid = 9,
     reqLBWorkerSetTaskCid = 10,
     rspLBWorkerSetTaskCid = 11,
     reqLBWorkerStopTaskCid = 12,
     rspLBWorkerStopTaskCid = 13
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
     ReqLBMasterHeartBeat		*reqLBMasterHeartBeat;
     RspLBMasterHeartBeat		*rspLBMasterHeartBeat;
     ReqLBMasterAddTask		*reqLBMasterAddTask;
     RspLBMasterAddTask		*rspLBMasterAddTask;
     ReqLBMasterDoTask		*reqLBMasterDoTask;
     RspLBMasterDoTask		*rspLBMasterDoTask;
     ReqLBWorkerHeartBeat		*reqLBWorkerHeartBeat;
     RspLBWorkerHeartBeat		*rspLBWorkerHeartBeat;
     ReqLBWorkerQueryTask		*reqLBWorkerQueryTask;
     RspLBWorkerQueryTask		*rspLBWorkerQueryTask;
     ReqLBWorkerSetTask		*reqLBWorkerSetTask;
     RspLBWorkerSetTask		*rspLBWorkerSetTask;
     ReqLBWorkerStopTask		*reqLBWorkerStopTask;
     RspLBWorkerStopTask		*rspLBWorkerStopTask;
  };


			BODYPKTS();
			BODYPKTS (const BODYPKTS &);
			~BODYPKTS();

  AsnType		*Clone() const;

  BODYPKTS		&operator = (const BODYPKTS &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void			Print (ostream &os) const;
};


class LotteryBonsMessage: public AsnType
{
public:
  AsnInt		iVer;
  AsnInt		iBirthsec;
  AsnInt		iBirthusec;
  AsnInt		iReserved;
  AsnInt		iSeq;
  AsnOcts		sExtBlob;
  BODYPKTS		*body;

			LotteryBonsMessage();
			LotteryBonsMessage (const LotteryBonsMessage &);
			~LotteryBonsMessage();
  AsnType		*Clone() const;

  LotteryBonsMessage		&operator = (const LotteryBonsMessage &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class LBStringList: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    AsnOcts	*elmt;
  }			*first, *curr, *last;

public:
			LBStringList() { count = 0; first = curr = last = NULL; }
			LBStringList (const LBStringList &);
			~LBStringList();
  AsnType		*Clone() const;

  LBStringList		&operator = (const LBStringList &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  AsnOcts	*First() const	{ return count > 0 ? first->elmt : NULL; }
  AsnOcts	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  AsnOcts	*Curr() const	{ return curr ? curr->elmt : NULL; }
  AsnOcts	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  AsnOcts	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  AsnOcts	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  AsnOcts	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  AsnOcts	*Append();  // add elmt to end of list
  AsnOcts	*Prepend(); // add elmt to beginning of list
  AsnOcts	*InsertBefore(); //insert elmt before current elmt
  AsnOcts	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  LBStringList	&AppendCopy (AsnOcts &elmt);  // add elmt to end of list
  LBStringList	&PrependCopy (AsnOcts &elmt); // add elmt to beginning of list
  LBStringList	&InsertBeforeAndCopy (AsnOcts &elmt); //insert elmt before current elmt
  LBStringList	&InsertAfterAndCopy (AsnOcts &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


//------------------------------------------------------------------------------
// externs for value defs

//------------------------------------------------------------------------------
}/* end of namespace NS_LotteryBons */


#endif /* conditional include of lottery_bons_pkt.h */
