//   NOTE: this is a machine generated file--editing not recommended
//
// lottery_bons_pkt.C - class member functions for ASN.1 module LOTTERYBONSMESSAGE
//
//   This file was generated by snacc on Thu Dec 11 21:06:26 2014
//   UBC snacc written by Mike Sample
//   A couple of enhancements made by IBM European Networking Center


#include "asn-incl.h"
#include "lottery_bons_pkt.h"

//------------------------------------------------------------------------------
// value defs


// using namespace:

using namespace NS_LotteryBons;

//------------------------------------------------------------------------------
// class member definitions:

LBNameValue::LBNameValue()
{
}

LBNameValue::LBNameValue (const LBNameValue &)
{
  Asn1Error << "use of incompletely defined LBNameValue::LBNameValue (const LBNameValue &)" << endl;
  abort();
}

LBNameValue::~LBNameValue()
{
}

AsnType *LBNameValue::Clone() const
{
  return new LBNameValue;
}

#if SNACC_DEEP_COPY
LBNameValue &LBNameValue::operator = (const LBNameValue &that)
#else // SNACC_DEEP_COPY
LBNameValue &LBNameValue::operator = (const LBNameValue &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    name = that.name;
    value = that.value;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined LBNameValue &LBNameValue::operator = (const LBNameValue &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
LBNameValue::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

    l = value.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = name.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

  return totalLen;
} // LBNameValue::BEncContent


void LBNameValue::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    name.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -100);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    value.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -101);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -102);
  }
  else
    return;
} // LBNameValue::BDecContent

AsnLen LBNameValue::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void LBNameValue::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "LBNameValue::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -103);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int LBNameValue::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int LBNameValue::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void LBNameValue::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "name ";
    os << name;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "value ";
    os << value;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // LBNameValue::Print


AsnType *LBNameValueList::Clone() const
{
  return new LBNameValueList;
}

AsnLen LBNameValueList::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void LBNameValueList::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "LBNameValueList::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -104);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

LBNameValueList::LBNameValueList (const LBNameValueList &)
{
  Asn1Error << "use of incompletely defined LBNameValueList::LBNameValueList (const LBNameValueList &)" << endl;
  abort();
}

LBNameValueList::~LBNameValueList()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
LBNameValueList &LBNameValueList::operator = (const LBNameValueList &that)
#else // SNACC_DEEP_COPY
LBNameValueList &LBNameValueList::operator = (const LBNameValueList &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined LBNameValueList &LBNameValueList::operator = (const LBNameValueList &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void LBNameValueList::Print (ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  LBNameValueList::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // LBNameValueList::SetCurrElmt


unsigned long int  LBNameValueList::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // LBNameValueList::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
LBNameValue *LBNameValueList::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new LBNameValue;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // LBNameValueList::Append


// alloc new list elmt, put at begining of list
//  and return the component type
LBNameValue  *LBNameValueList::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new LBNameValue;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // LBNameValueList::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
LBNameValue  *LBNameValueList::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new LBNameValue;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // LBNameValueList::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
LBNameValue *LBNameValueList::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new LBNameValue;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // LBNameValueList::InsertAfter


LBNameValueList  &LBNameValueList::AppendCopy (LBNameValue &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new LBNameValue;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


LBNameValueList  &LBNameValueList::PrependCopy (LBNameValue &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new LBNameValue;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // LBNameValueList::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
LBNameValueList &LBNameValueList::InsertBeforeAndCopy (LBNameValue &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new LBNameValue;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // LBNameValueList::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
LBNameValueList  &LBNameValueList::InsertAfterAndCopy (LBNameValue &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new LBNameValue;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // LBNameValueList::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void LBNameValueList::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen LBNameValueList::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // LBNameValueList::BEncContent


void  LBNameValueList::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    LBNameValue *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            longjmp (env, -105);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // LBNameValueList::BDecContent


TASK::TASK()
{
}

TASK::TASK (const TASK &)
{
  Asn1Error << "use of incompletely defined TASK::TASK (const TASK &)" << endl;
  abort();
}

TASK::~TASK()
{
}

AsnType *TASK::Clone() const
{
  return new TASK;
}

#if SNACC_DEEP_COPY
TASK &TASK::operator = (const TASK &that)
#else // SNACC_DEEP_COPY
TASK &TASK::operator = (const TASK &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    taskID = that.taskID;
    taskType = that.taskType;
    taskState = that.taskState;
    lotteryName = that.lotteryName;
    lotteryPlay = that.lotteryPlay;
    conditionSql = that.conditionSql;
    qihaoBegin = that.qihaoBegin;
    qihaoEnd = that.qihaoEnd;
    projectBegin = that.projectBegin;
    projectEnd = that.projectEnd;
    fracMod = that.fracMod;
    denoMod = that.denoMod;
    isUpdateDB = that.isUpdateDB;
    isUpdateFile = that.isUpdateFile;
    isForceRecompute = that.isForceRecompute;
    isEarlyPayBonus = that.isEarlyPayBonus;
    iReserve1 = that.iReserve1;
    iReserve2 = that.iReserve2;
    strReserve1 = that.strReserve1;
    strReserve2 = that.strReserve2;
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined TASK &TASK::operator = (const TASK &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
TASK::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = strReserve2.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = strReserve1.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = iReserve2.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = iReserve1.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = isEarlyPayBonus.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = isForceRecompute.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = isUpdateFile.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = isUpdateDB.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = denoMod.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = fracMod.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = projectEnd.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = projectBegin.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = qihaoEnd.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = qihaoBegin.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = conditionSql.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = lotteryPlay.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = lotteryName.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = taskState.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = taskType.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = taskID.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // TASK::BEncContent


void TASK::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    taskID.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -106);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    taskType.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -107);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    taskState.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -108);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    lotteryName.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -109);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    lotteryPlay.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -110);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    conditionSql.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -111);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    qihaoBegin.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -112);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    qihaoEnd.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -113);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    projectBegin.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -114);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    projectEnd.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -115);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    fracMod.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -116);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    denoMod.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -117);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    isUpdateDB.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -118);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    isUpdateFile.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -119);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    isForceRecompute.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -120);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    isEarlyPayBonus.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -121);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iReserve1.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -122);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iReserve2.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -123);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    strReserve1.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -124);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    strReserve2.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -125);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -126);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -127);
  }
  else
    return;
} // TASK::BDecContent

AsnLen TASK::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TASK::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "TASK::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -128);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int TASK::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int TASK::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void TASK::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "taskID ";
    os << taskID;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "taskType ";
    os << taskType;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "taskState ";
    os << taskState;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "lotteryName ";
    os << lotteryName;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "lotteryPlay ";
    os << lotteryPlay;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "conditionSql ";
    os << conditionSql;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "qihaoBegin ";
    os << qihaoBegin;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "qihaoEnd ";
    os << qihaoEnd;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "projectBegin ";
    os << projectBegin;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "projectEnd ";
    os << projectEnd;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "fracMod ";
    os << fracMod;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "denoMod ";
    os << denoMod;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "isUpdateDB ";
    os << isUpdateDB;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "isUpdateFile ";
    os << isUpdateFile;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "isForceRecompute ";
    os << isForceRecompute;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "isEarlyPayBonus ";
    os << isEarlyPayBonus;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "iReserve1 ";
    os << iReserve1;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "iReserve2 ";
    os << iReserve2;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "strReserve1 ";
    os << strReserve1;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "strReserve2 ";
    os << strReserve2;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // TASK::Print


AsnType *TASKList::Clone() const
{
  return new TASKList;
}

AsnLen TASKList::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TASKList::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "TASKList::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -129);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

TASKList::TASKList (const TASKList &)
{
  Asn1Error << "use of incompletely defined TASKList::TASKList (const TASKList &)" << endl;
  abort();
}

TASKList::~TASKList()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
TASKList &TASKList::operator = (const TASKList &that)
#else // SNACC_DEEP_COPY
TASKList &TASKList::operator = (const TASKList &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined TASKList &TASKList::operator = (const TASKList &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void TASKList::Print (ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  TASKList::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // TASKList::SetCurrElmt


unsigned long int  TASKList::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // TASKList::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
TASK *TASKList::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new TASK;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // TASKList::Append


// alloc new list elmt, put at begining of list
//  and return the component type
TASK  *TASKList::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new TASK;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // TASKList::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
TASK  *TASKList::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new TASK;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // TASKList::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
TASK *TASKList::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new TASK;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // TASKList::InsertAfter


TASKList  &TASKList::AppendCopy (TASK &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new TASK;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


TASKList  &TASKList::PrependCopy (TASK &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new TASK;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // TASKList::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
TASKList &TASKList::InsertBeforeAndCopy (TASK &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new TASK;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // TASKList::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
TASKList  &TASKList::InsertAfterAndCopy (TASK &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new TASK;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // TASKList::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void TASKList::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen TASKList::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // TASKList::BEncContent


void  TASKList::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    TASK *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            longjmp (env, -130);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // TASKList::BDecContent


ReqLBMasterHeartBeat::ReqLBMasterHeartBeat()
{
}

ReqLBMasterHeartBeat::ReqLBMasterHeartBeat (const ReqLBMasterHeartBeat &)
{
  Asn1Error << "use of incompletely defined ReqLBMasterHeartBeat::ReqLBMasterHeartBeat (const ReqLBMasterHeartBeat &)" << endl;
  abort();
}

ReqLBMasterHeartBeat::~ReqLBMasterHeartBeat()
{
}

AsnType *ReqLBMasterHeartBeat::Clone() const
{
  return new ReqLBMasterHeartBeat;
}

#if SNACC_DEEP_COPY
ReqLBMasterHeartBeat &ReqLBMasterHeartBeat::operator = (const ReqLBMasterHeartBeat &that)
#else // SNACC_DEEP_COPY
ReqLBMasterHeartBeat &ReqLBMasterHeartBeat::operator = (const ReqLBMasterHeartBeat &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    hbMod = that.hbMod;
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReqLBMasterHeartBeat &ReqLBMasterHeartBeat::operator = (const ReqLBMasterHeartBeat &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ReqLBMasterHeartBeat::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = hbMod.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ReqLBMasterHeartBeat::BEncContent


void ReqLBMasterHeartBeat::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    hbMod.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -131);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -132);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -133);
  }
  else
    return;
} // ReqLBMasterHeartBeat::BDecContent

AsnLen ReqLBMasterHeartBeat::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReqLBMasterHeartBeat::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReqLBMasterHeartBeat::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -134);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int ReqLBMasterHeartBeat::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int ReqLBMasterHeartBeat::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void ReqLBMasterHeartBeat::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "hbMod ";
    os << hbMod;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // ReqLBMasterHeartBeat::Print


RspLBMasterHeartBeat::RspLBMasterHeartBeat()
{
}

RspLBMasterHeartBeat::RspLBMasterHeartBeat (const RspLBMasterHeartBeat &)
{
  Asn1Error << "use of incompletely defined RspLBMasterHeartBeat::RspLBMasterHeartBeat (const RspLBMasterHeartBeat &)" << endl;
  abort();
}

RspLBMasterHeartBeat::~RspLBMasterHeartBeat()
{
}

AsnType *RspLBMasterHeartBeat::Clone() const
{
  return new RspLBMasterHeartBeat;
}

#if SNACC_DEEP_COPY
RspLBMasterHeartBeat &RspLBMasterHeartBeat::operator = (const RspLBMasterHeartBeat &that)
#else // SNACC_DEEP_COPY
RspLBMasterHeartBeat &RspLBMasterHeartBeat::operator = (const RspLBMasterHeartBeat &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    retCode = that.retCode;
    svrInfo = that.svrInfo;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined RspLBMasterHeartBeat &RspLBMasterHeartBeat::operator = (const RspLBMasterHeartBeat &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
RspLBMasterHeartBeat::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = svrInfo.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = retCode.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // RspLBMasterHeartBeat::BEncContent


void RspLBMasterHeartBeat::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    retCode.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -135);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    svrInfo.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -136);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -137);
  }
  else
    return;
} // RspLBMasterHeartBeat::BDecContent

AsnLen RspLBMasterHeartBeat::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void RspLBMasterHeartBeat::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "RspLBMasterHeartBeat::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -138);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int RspLBMasterHeartBeat::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int RspLBMasterHeartBeat::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void RspLBMasterHeartBeat::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "retCode ";
    os << retCode;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "svrInfo ";
    os << svrInfo;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // RspLBMasterHeartBeat::Print


ReqLBMasterAddTask::ReqLBMasterAddTask()
{
}

ReqLBMasterAddTask::ReqLBMasterAddTask (const ReqLBMasterAddTask &)
{
  Asn1Error << "use of incompletely defined ReqLBMasterAddTask::ReqLBMasterAddTask (const ReqLBMasterAddTask &)" << endl;
  abort();
}

ReqLBMasterAddTask::~ReqLBMasterAddTask()
{
}

AsnType *ReqLBMasterAddTask::Clone() const
{
  return new ReqLBMasterAddTask;
}

#if SNACC_DEEP_COPY
ReqLBMasterAddTask &ReqLBMasterAddTask::operator = (const ReqLBMasterAddTask &that)
#else // SNACC_DEEP_COPY
ReqLBMasterAddTask &ReqLBMasterAddTask::operator = (const ReqLBMasterAddTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    tasks = that.tasks;
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReqLBMasterAddTask &ReqLBMasterAddTask::operator = (const ReqLBMasterAddTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ReqLBMasterAddTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

      BEncEocIfNec (b);
    l = tasks.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ReqLBMasterAddTask::BEncContent


void ReqLBMasterAddTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tasks.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -139);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -140);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -141);
  }
  else
    return;
} // ReqLBMasterAddTask::BDecContent

AsnLen ReqLBMasterAddTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReqLBMasterAddTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReqLBMasterAddTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -142);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int ReqLBMasterAddTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int ReqLBMasterAddTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void ReqLBMasterAddTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "tasks ";
    os << tasks;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // ReqLBMasterAddTask::Print


RspLBMasterAddTask::RspLBMasterAddTask()
{
}

RspLBMasterAddTask::RspLBMasterAddTask (const RspLBMasterAddTask &)
{
  Asn1Error << "use of incompletely defined RspLBMasterAddTask::RspLBMasterAddTask (const RspLBMasterAddTask &)" << endl;
  abort();
}

RspLBMasterAddTask::~RspLBMasterAddTask()
{
}

AsnType *RspLBMasterAddTask::Clone() const
{
  return new RspLBMasterAddTask;
}

#if SNACC_DEEP_COPY
RspLBMasterAddTask &RspLBMasterAddTask::operator = (const RspLBMasterAddTask &that)
#else // SNACC_DEEP_COPY
RspLBMasterAddTask &RspLBMasterAddTask::operator = (const RspLBMasterAddTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    retCode = that.retCode;
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined RspLBMasterAddTask &RspLBMasterAddTask::operator = (const RspLBMasterAddTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
RspLBMasterAddTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = retCode.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // RspLBMasterAddTask::BEncContent


void RspLBMasterAddTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    retCode.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -143);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -144);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -145);
  }
  else
    return;
} // RspLBMasterAddTask::BDecContent

AsnLen RspLBMasterAddTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void RspLBMasterAddTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "RspLBMasterAddTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -146);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int RspLBMasterAddTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int RspLBMasterAddTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void RspLBMasterAddTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "retCode ";
    os << retCode;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // RspLBMasterAddTask::Print


ReqLBMasterDoTask::ReqLBMasterDoTask()
{
}

ReqLBMasterDoTask::ReqLBMasterDoTask (const ReqLBMasterDoTask &)
{
  Asn1Error << "use of incompletely defined ReqLBMasterDoTask::ReqLBMasterDoTask (const ReqLBMasterDoTask &)" << endl;
  abort();
}

ReqLBMasterDoTask::~ReqLBMasterDoTask()
{
}

AsnType *ReqLBMasterDoTask::Clone() const
{
  return new ReqLBMasterDoTask;
}

#if SNACC_DEEP_COPY
ReqLBMasterDoTask &ReqLBMasterDoTask::operator = (const ReqLBMasterDoTask &that)
#else // SNACC_DEEP_COPY
ReqLBMasterDoTask &ReqLBMasterDoTask::operator = (const ReqLBMasterDoTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    tasks = that.tasks;
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReqLBMasterDoTask &ReqLBMasterDoTask::operator = (const ReqLBMasterDoTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ReqLBMasterDoTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

      BEncEocIfNec (b);
    l = tasks.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ReqLBMasterDoTask::BEncContent


void ReqLBMasterDoTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    tasks.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -147);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -148);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -149);
  }
  else
    return;
} // ReqLBMasterDoTask::BDecContent

AsnLen ReqLBMasterDoTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReqLBMasterDoTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReqLBMasterDoTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -150);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int ReqLBMasterDoTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int ReqLBMasterDoTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void ReqLBMasterDoTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "tasks ";
    os << tasks;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // ReqLBMasterDoTask::Print


RspLBMasterDoTask::RspLBMasterDoTask()
{
}

RspLBMasterDoTask::RspLBMasterDoTask (const RspLBMasterDoTask &)
{
  Asn1Error << "use of incompletely defined RspLBMasterDoTask::RspLBMasterDoTask (const RspLBMasterDoTask &)" << endl;
  abort();
}

RspLBMasterDoTask::~RspLBMasterDoTask()
{
}

AsnType *RspLBMasterDoTask::Clone() const
{
  return new RspLBMasterDoTask;
}

#if SNACC_DEEP_COPY
RspLBMasterDoTask &RspLBMasterDoTask::operator = (const RspLBMasterDoTask &that)
#else // SNACC_DEEP_COPY
RspLBMasterDoTask &RspLBMasterDoTask::operator = (const RspLBMasterDoTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    retCode = that.retCode;
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined RspLBMasterDoTask &RspLBMasterDoTask::operator = (const RspLBMasterDoTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
RspLBMasterDoTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = retCode.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // RspLBMasterDoTask::BEncContent


void RspLBMasterDoTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    retCode.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -151);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -152);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -153);
  }
  else
    return;
} // RspLBMasterDoTask::BDecContent

AsnLen RspLBMasterDoTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void RspLBMasterDoTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "RspLBMasterDoTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -154);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int RspLBMasterDoTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int RspLBMasterDoTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void RspLBMasterDoTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "retCode ";
    os << retCode;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // RspLBMasterDoTask::Print


ReqLBWorkerHeartBeat::ReqLBWorkerHeartBeat()
{
}

ReqLBWorkerHeartBeat::ReqLBWorkerHeartBeat (const ReqLBWorkerHeartBeat &)
{
  Asn1Error << "use of incompletely defined ReqLBWorkerHeartBeat::ReqLBWorkerHeartBeat (const ReqLBWorkerHeartBeat &)" << endl;
  abort();
}

ReqLBWorkerHeartBeat::~ReqLBWorkerHeartBeat()
{
}

AsnType *ReqLBWorkerHeartBeat::Clone() const
{
  return new ReqLBWorkerHeartBeat;
}

#if SNACC_DEEP_COPY
ReqLBWorkerHeartBeat &ReqLBWorkerHeartBeat::operator = (const ReqLBWorkerHeartBeat &that)
#else // SNACC_DEEP_COPY
ReqLBWorkerHeartBeat &ReqLBWorkerHeartBeat::operator = (const ReqLBWorkerHeartBeat &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    hbMod = that.hbMod;
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReqLBWorkerHeartBeat &ReqLBWorkerHeartBeat::operator = (const ReqLBWorkerHeartBeat &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ReqLBWorkerHeartBeat::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = hbMod.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ReqLBWorkerHeartBeat::BEncContent


void ReqLBWorkerHeartBeat::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    hbMod.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -155);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -156);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -157);
  }
  else
    return;
} // ReqLBWorkerHeartBeat::BDecContent

AsnLen ReqLBWorkerHeartBeat::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReqLBWorkerHeartBeat::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReqLBWorkerHeartBeat::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -158);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int ReqLBWorkerHeartBeat::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int ReqLBWorkerHeartBeat::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void ReqLBWorkerHeartBeat::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "hbMod ";
    os << hbMod;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // ReqLBWorkerHeartBeat::Print


RspLBWorkerHeartBeat::RspLBWorkerHeartBeat()
{
}

RspLBWorkerHeartBeat::RspLBWorkerHeartBeat (const RspLBWorkerHeartBeat &)
{
  Asn1Error << "use of incompletely defined RspLBWorkerHeartBeat::RspLBWorkerHeartBeat (const RspLBWorkerHeartBeat &)" << endl;
  abort();
}

RspLBWorkerHeartBeat::~RspLBWorkerHeartBeat()
{
}

AsnType *RspLBWorkerHeartBeat::Clone() const
{
  return new RspLBWorkerHeartBeat;
}

#if SNACC_DEEP_COPY
RspLBWorkerHeartBeat &RspLBWorkerHeartBeat::operator = (const RspLBWorkerHeartBeat &that)
#else // SNACC_DEEP_COPY
RspLBWorkerHeartBeat &RspLBWorkerHeartBeat::operator = (const RspLBWorkerHeartBeat &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    retCode = that.retCode;
    svrInfo = that.svrInfo;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined RspLBWorkerHeartBeat &RspLBWorkerHeartBeat::operator = (const RspLBWorkerHeartBeat &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
RspLBWorkerHeartBeat::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = svrInfo.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = retCode.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // RspLBWorkerHeartBeat::BEncContent


void RspLBWorkerHeartBeat::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    retCode.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -159);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    svrInfo.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -160);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -161);
  }
  else
    return;
} // RspLBWorkerHeartBeat::BDecContent

AsnLen RspLBWorkerHeartBeat::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void RspLBWorkerHeartBeat::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "RspLBWorkerHeartBeat::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -162);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int RspLBWorkerHeartBeat::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int RspLBWorkerHeartBeat::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void RspLBWorkerHeartBeat::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "retCode ";
    os << retCode;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "svrInfo ";
    os << svrInfo;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // RspLBWorkerHeartBeat::Print


ReqLBWorkerQueryTask::ReqLBWorkerQueryTask()
{
}

ReqLBWorkerQueryTask::ReqLBWorkerQueryTask (const ReqLBWorkerQueryTask &)
{
  Asn1Error << "use of incompletely defined ReqLBWorkerQueryTask::ReqLBWorkerQueryTask (const ReqLBWorkerQueryTask &)" << endl;
  abort();
}

ReqLBWorkerQueryTask::~ReqLBWorkerQueryTask()
{
}

AsnType *ReqLBWorkerQueryTask::Clone() const
{
  return new ReqLBWorkerQueryTask;
}

#if SNACC_DEEP_COPY
ReqLBWorkerQueryTask &ReqLBWorkerQueryTask::operator = (const ReqLBWorkerQueryTask &that)
#else // SNACC_DEEP_COPY
ReqLBWorkerQueryTask &ReqLBWorkerQueryTask::operator = (const ReqLBWorkerQueryTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReqLBWorkerQueryTask &ReqLBWorkerQueryTask::operator = (const ReqLBWorkerQueryTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ReqLBWorkerQueryTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ReqLBWorkerQueryTask::BEncContent


void ReqLBWorkerQueryTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -163);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -164);
  }
  else
    return;
} // ReqLBWorkerQueryTask::BDecContent

AsnLen ReqLBWorkerQueryTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReqLBWorkerQueryTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReqLBWorkerQueryTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -165);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int ReqLBWorkerQueryTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int ReqLBWorkerQueryTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void ReqLBWorkerQueryTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // ReqLBWorkerQueryTask::Print


RspLBWorkerQueryTask::RspLBWorkerQueryTask()
{
#if TCL
  taskInfo = new TASK;
#else
  taskInfo = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

RspLBWorkerQueryTask::RspLBWorkerQueryTask (const RspLBWorkerQueryTask &)
{
  Asn1Error << "use of incompletely defined RspLBWorkerQueryTask::RspLBWorkerQueryTask (const RspLBWorkerQueryTask &)" << endl;
  abort();
}

RspLBWorkerQueryTask::~RspLBWorkerQueryTask()
{
  delete taskInfo;
}

AsnType *RspLBWorkerQueryTask::Clone() const
{
  return new RspLBWorkerQueryTask;
}

#if SNACC_DEEP_COPY
RspLBWorkerQueryTask &RspLBWorkerQueryTask::operator = (const RspLBWorkerQueryTask &that)
#else // SNACC_DEEP_COPY
RspLBWorkerQueryTask &RspLBWorkerQueryTask::operator = (const RspLBWorkerQueryTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    retCode = that.retCode;
    if (that.taskInfo)
    {
      if (!taskInfo)
        taskInfo = new TASK;
      *taskInfo = *that.taskInfo;
    }
    else
    {
      delete taskInfo;
      taskInfo = NULL;
    }
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined RspLBWorkerQueryTask &RspLBWorkerQueryTask::operator = (const RspLBWorkerQueryTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
RspLBWorkerQueryTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

      BEncEocIfNec (b);
    l = taskInfo->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = retCode.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // RspLBWorkerQueryTask::BEncContent


void RspLBWorkerQueryTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    retCode.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -166);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    taskInfo = new TASK;
    taskInfo->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -167);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -168);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -169);
  }
  else
    return;
} // RspLBWorkerQueryTask::BDecContent

AsnLen RspLBWorkerQueryTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void RspLBWorkerQueryTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "RspLBWorkerQueryTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -170);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int RspLBWorkerQueryTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int RspLBWorkerQueryTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void RspLBWorkerQueryTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "retCode ";
    os << retCode;
    os << "," << endl;
  }

  if (NOT_NULL (taskInfo))
  {
    Indent (os, indentG);
    os << "taskInfo ";
    os << *taskInfo;
  }
  else
  {
    Indent (os, indentG);
    os << "taskInfo ";
    os << "-- void --";
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // RspLBWorkerQueryTask::Print


ReqLBWorkerSetTask::ReqLBWorkerSetTask()
{
#if TCL
  taskInfo = new TASK;
#else
  taskInfo = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

ReqLBWorkerSetTask::ReqLBWorkerSetTask (const ReqLBWorkerSetTask &)
{
  Asn1Error << "use of incompletely defined ReqLBWorkerSetTask::ReqLBWorkerSetTask (const ReqLBWorkerSetTask &)" << endl;
  abort();
}

ReqLBWorkerSetTask::~ReqLBWorkerSetTask()
{
  delete taskInfo;
}

AsnType *ReqLBWorkerSetTask::Clone() const
{
  return new ReqLBWorkerSetTask;
}

#if SNACC_DEEP_COPY
ReqLBWorkerSetTask &ReqLBWorkerSetTask::operator = (const ReqLBWorkerSetTask &that)
#else // SNACC_DEEP_COPY
ReqLBWorkerSetTask &ReqLBWorkerSetTask::operator = (const ReqLBWorkerSetTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.taskInfo)
    {
      if (!taskInfo)
        taskInfo = new TASK;
      *taskInfo = *that.taskInfo;
    }
    else
    {
      delete taskInfo;
      taskInfo = NULL;
    }
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReqLBWorkerSetTask &ReqLBWorkerSetTask::operator = (const ReqLBWorkerSetTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ReqLBWorkerSetTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

      BEncEocIfNec (b);
    l = taskInfo->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ReqLBWorkerSetTask::BEncContent


void ReqLBWorkerSetTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    taskInfo = new TASK;
    taskInfo->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -171);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -172);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -173);
  }
  else
    return;
} // ReqLBWorkerSetTask::BDecContent

AsnLen ReqLBWorkerSetTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReqLBWorkerSetTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReqLBWorkerSetTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -174);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int ReqLBWorkerSetTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int ReqLBWorkerSetTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void ReqLBWorkerSetTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  if (NOT_NULL (taskInfo))
  {
    Indent (os, indentG);
    os << "taskInfo ";
    os << *taskInfo;
  }
  else
  {
    Indent (os, indentG);
    os << "taskInfo ";
    os << "-- void --";
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // ReqLBWorkerSetTask::Print


RspLBWorkerSetTask::RspLBWorkerSetTask()
{
}

RspLBWorkerSetTask::RspLBWorkerSetTask (const RspLBWorkerSetTask &)
{
  Asn1Error << "use of incompletely defined RspLBWorkerSetTask::RspLBWorkerSetTask (const RspLBWorkerSetTask &)" << endl;
  abort();
}

RspLBWorkerSetTask::~RspLBWorkerSetTask()
{
}

AsnType *RspLBWorkerSetTask::Clone() const
{
  return new RspLBWorkerSetTask;
}

#if SNACC_DEEP_COPY
RspLBWorkerSetTask &RspLBWorkerSetTask::operator = (const RspLBWorkerSetTask &that)
#else // SNACC_DEEP_COPY
RspLBWorkerSetTask &RspLBWorkerSetTask::operator = (const RspLBWorkerSetTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    retCode = that.retCode;
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined RspLBWorkerSetTask &RspLBWorkerSetTask::operator = (const RspLBWorkerSetTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
RspLBWorkerSetTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = retCode.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // RspLBWorkerSetTask::BEncContent


void RspLBWorkerSetTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    retCode.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -175);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -176);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -177);
  }
  else
    return;
} // RspLBWorkerSetTask::BDecContent

AsnLen RspLBWorkerSetTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void RspLBWorkerSetTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "RspLBWorkerSetTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -178);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int RspLBWorkerSetTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int RspLBWorkerSetTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void RspLBWorkerSetTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "retCode ";
    os << retCode;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // RspLBWorkerSetTask::Print


ReqLBWorkerStopTask::ReqLBWorkerStopTask()
{
#if TCL
  taskInfo = new TASK;
#else
  taskInfo = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

ReqLBWorkerStopTask::ReqLBWorkerStopTask (const ReqLBWorkerStopTask &)
{
  Asn1Error << "use of incompletely defined ReqLBWorkerStopTask::ReqLBWorkerStopTask (const ReqLBWorkerStopTask &)" << endl;
  abort();
}

ReqLBWorkerStopTask::~ReqLBWorkerStopTask()
{
  delete taskInfo;
}

AsnType *ReqLBWorkerStopTask::Clone() const
{
  return new ReqLBWorkerStopTask;
}

#if SNACC_DEEP_COPY
ReqLBWorkerStopTask &ReqLBWorkerStopTask::operator = (const ReqLBWorkerStopTask &that)
#else // SNACC_DEEP_COPY
ReqLBWorkerStopTask &ReqLBWorkerStopTask::operator = (const ReqLBWorkerStopTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.taskInfo)
    {
      if (!taskInfo)
        taskInfo = new TASK;
      *taskInfo = *that.taskInfo;
    }
    else
    {
      delete taskInfo;
      taskInfo = NULL;
    }
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReqLBWorkerStopTask &ReqLBWorkerStopTask::operator = (const ReqLBWorkerStopTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ReqLBWorkerStopTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

      BEncEocIfNec (b);
    l = taskInfo->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ReqLBWorkerStopTask::BEncContent


void ReqLBWorkerStopTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    taskInfo = new TASK;
    taskInfo->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -179);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -180);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -181);
  }
  else
    return;
} // ReqLBWorkerStopTask::BDecContent

AsnLen ReqLBWorkerStopTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReqLBWorkerStopTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReqLBWorkerStopTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -182);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int ReqLBWorkerStopTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int ReqLBWorkerStopTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void ReqLBWorkerStopTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  if (NOT_NULL (taskInfo))
  {
    Indent (os, indentG);
    os << "taskInfo ";
    os << *taskInfo;
  }
  else
  {
    Indent (os, indentG);
    os << "taskInfo ";
    os << "-- void --";
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // ReqLBWorkerStopTask::Print


RspLBWorkerStopTask::RspLBWorkerStopTask()
{
}

RspLBWorkerStopTask::RspLBWorkerStopTask (const RspLBWorkerStopTask &)
{
  Asn1Error << "use of incompletely defined RspLBWorkerStopTask::RspLBWorkerStopTask (const RspLBWorkerStopTask &)" << endl;
  abort();
}

RspLBWorkerStopTask::~RspLBWorkerStopTask()
{
}

AsnType *RspLBWorkerStopTask::Clone() const
{
  return new RspLBWorkerStopTask;
}

#if SNACC_DEEP_COPY
RspLBWorkerStopTask &RspLBWorkerStopTask::operator = (const RspLBWorkerStopTask &that)
#else // SNACC_DEEP_COPY
RspLBWorkerStopTask &RspLBWorkerStopTask::operator = (const RspLBWorkerStopTask &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    retCode = that.retCode;
    reserve = that.reserve;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined RspLBWorkerStopTask &RspLBWorkerStopTask::operator = (const RspLBWorkerStopTask &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
RspLBWorkerStopTask::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = reserve.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = retCode.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // RspLBWorkerStopTask::BEncContent


void RspLBWorkerStopTask::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    retCode.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -183);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    reserve.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -184);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -185);
  }
  else
    return;
} // RspLBWorkerStopTask::BDecContent

AsnLen RspLBWorkerStopTask::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void RspLBWorkerStopTask::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "RspLBWorkerStopTask::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -186);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int RspLBWorkerStopTask::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int RspLBWorkerStopTask::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void RspLBWorkerStopTask::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "retCode ";
    os << retCode;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "reserve ";
    os << reserve;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // RspLBWorkerStopTask::Print


BODYPKTS::BODYPKTS()
{
  choiceId = reqLBMasterHeartBeatCid;
#if TCL
  reqLBMasterHeartBeat = new ReqLBMasterHeartBeat;
#else
  reqLBMasterHeartBeat = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

BODYPKTS::BODYPKTS (const BODYPKTS &)
{
  Asn1Error << "use of incompletely defined BODYPKTS::BODYPKTS (const BODYPKTS &)" << endl;
  abort();
}

BODYPKTS::~BODYPKTS()
{
  switch (choiceId)
  {
    case reqLBMasterHeartBeatCid:
      delete reqLBMasterHeartBeat;
      break;
    case rspLBMasterHeartBeatCid:
      delete rspLBMasterHeartBeat;
      break;
    case reqLBMasterAddTaskCid:
      delete reqLBMasterAddTask;
      break;
    case rspLBMasterAddTaskCid:
      delete rspLBMasterAddTask;
      break;
    case reqLBMasterDoTaskCid:
      delete reqLBMasterDoTask;
      break;
    case rspLBMasterDoTaskCid:
      delete rspLBMasterDoTask;
      break;
    case reqLBWorkerHeartBeatCid:
      delete reqLBWorkerHeartBeat;
      break;
    case rspLBWorkerHeartBeatCid:
      delete rspLBWorkerHeartBeat;
      break;
    case reqLBWorkerQueryTaskCid:
      delete reqLBWorkerQueryTask;
      break;
    case rspLBWorkerQueryTaskCid:
      delete rspLBWorkerQueryTask;
      break;
    case reqLBWorkerSetTaskCid:
      delete reqLBWorkerSetTask;
      break;
    case rspLBWorkerSetTaskCid:
      delete rspLBWorkerSetTask;
      break;
    case reqLBWorkerStopTaskCid:
      delete reqLBWorkerStopTask;
      break;
    case rspLBWorkerStopTaskCid:
      delete rspLBWorkerStopTask;
      break;
  } // end of switch
} // end of destructor

AsnType *BODYPKTS::Clone() const
{
  return new BODYPKTS;
}

#if SNACC_DEEP_COPY
BODYPKTS &BODYPKTS::operator = (const BODYPKTS &that)
#else // SNACC_DEEP_COPY
BODYPKTS &BODYPKTS::operator = (const BODYPKTS &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case reqLBMasterHeartBeatCid:
        delete reqLBMasterHeartBeat;
        break;
      case rspLBMasterHeartBeatCid:
        delete rspLBMasterHeartBeat;
        break;
      case reqLBMasterAddTaskCid:
        delete reqLBMasterAddTask;
        break;
      case rspLBMasterAddTaskCid:
        delete rspLBMasterAddTask;
        break;
      case reqLBMasterDoTaskCid:
        delete reqLBMasterDoTask;
        break;
      case rspLBMasterDoTaskCid:
        delete rspLBMasterDoTask;
        break;
      case reqLBWorkerHeartBeatCid:
        delete reqLBWorkerHeartBeat;
        break;
      case rspLBWorkerHeartBeatCid:
        delete rspLBWorkerHeartBeat;
        break;
      case reqLBWorkerQueryTaskCid:
        delete reqLBWorkerQueryTask;
        break;
      case rspLBWorkerQueryTaskCid:
        delete rspLBWorkerQueryTask;
        break;
      case reqLBWorkerSetTaskCid:
        delete reqLBWorkerSetTask;
        break;
      case rspLBWorkerSetTaskCid:
        delete rspLBWorkerSetTask;
        break;
      case reqLBWorkerStopTaskCid:
        delete reqLBWorkerStopTask;
        break;
      case rspLBWorkerStopTaskCid:
        delete rspLBWorkerStopTask;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case reqLBMasterHeartBeatCid:
        reqLBMasterHeartBeat = new ReqLBMasterHeartBeat;
        *reqLBMasterHeartBeat = *that.reqLBMasterHeartBeat;
        break;
      case rspLBMasterHeartBeatCid:
        rspLBMasterHeartBeat = new RspLBMasterHeartBeat;
        *rspLBMasterHeartBeat = *that.rspLBMasterHeartBeat;
        break;
      case reqLBMasterAddTaskCid:
        reqLBMasterAddTask = new ReqLBMasterAddTask;
        *reqLBMasterAddTask = *that.reqLBMasterAddTask;
        break;
      case rspLBMasterAddTaskCid:
        rspLBMasterAddTask = new RspLBMasterAddTask;
        *rspLBMasterAddTask = *that.rspLBMasterAddTask;
        break;
      case reqLBMasterDoTaskCid:
        reqLBMasterDoTask = new ReqLBMasterDoTask;
        *reqLBMasterDoTask = *that.reqLBMasterDoTask;
        break;
      case rspLBMasterDoTaskCid:
        rspLBMasterDoTask = new RspLBMasterDoTask;
        *rspLBMasterDoTask = *that.rspLBMasterDoTask;
        break;
      case reqLBWorkerHeartBeatCid:
        reqLBWorkerHeartBeat = new ReqLBWorkerHeartBeat;
        *reqLBWorkerHeartBeat = *that.reqLBWorkerHeartBeat;
        break;
      case rspLBWorkerHeartBeatCid:
        rspLBWorkerHeartBeat = new RspLBWorkerHeartBeat;
        *rspLBWorkerHeartBeat = *that.rspLBWorkerHeartBeat;
        break;
      case reqLBWorkerQueryTaskCid:
        reqLBWorkerQueryTask = new ReqLBWorkerQueryTask;
        *reqLBWorkerQueryTask = *that.reqLBWorkerQueryTask;
        break;
      case rspLBWorkerQueryTaskCid:
        rspLBWorkerQueryTask = new RspLBWorkerQueryTask;
        *rspLBWorkerQueryTask = *that.rspLBWorkerQueryTask;
        break;
      case reqLBWorkerSetTaskCid:
        reqLBWorkerSetTask = new ReqLBWorkerSetTask;
        *reqLBWorkerSetTask = *that.reqLBWorkerSetTask;
        break;
      case rspLBWorkerSetTaskCid:
        rspLBWorkerSetTask = new RspLBWorkerSetTask;
        *rspLBWorkerSetTask = *that.rspLBWorkerSetTask;
        break;
      case reqLBWorkerStopTaskCid:
        reqLBWorkerStopTask = new ReqLBWorkerStopTask;
        *reqLBWorkerStopTask = *that.reqLBWorkerStopTask;
        break;
      case rspLBWorkerStopTaskCid:
        rspLBWorkerStopTask = new RspLBWorkerStopTask;
        *rspLBWorkerStopTask = *that.rspLBWorkerStopTask;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined BODYPKTS &BODYPKTS::operator = (const BODYPKTS &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
BODYPKTS::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case reqLBMasterHeartBeatCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = reqLBMasterHeartBeat->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 71101);
      break;

    case rspLBMasterHeartBeatCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = rspLBMasterHeartBeat->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 71102);
      break;

    case reqLBMasterAddTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = reqLBMasterAddTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 71111);
      break;

    case rspLBMasterAddTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = rspLBMasterAddTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 71112);
      break;

    case reqLBMasterDoTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = reqLBMasterDoTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 71113);
      break;

    case rspLBMasterDoTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = rspLBMasterDoTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 71114);
      break;

    case reqLBWorkerHeartBeatCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = reqLBWorkerHeartBeat->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 72101);
      break;

    case rspLBWorkerHeartBeatCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = rspLBWorkerHeartBeat->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 72102);
      break;

    case reqLBWorkerQueryTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = reqLBWorkerQueryTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 72103);
      break;

    case rspLBWorkerQueryTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = rspLBWorkerQueryTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 72104);
      break;

    case reqLBWorkerSetTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = reqLBWorkerSetTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 72105);
      break;

    case rspLBWorkerSetTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = rspLBWorkerSetTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 72106);
      break;

    case reqLBWorkerStopTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = reqLBWorkerStopTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 72107);
      break;

    case rspLBWorkerStopTaskCid:
      BEncEocIfNec (b);
      BEncEocIfNec (b);
      l = rspLBWorkerStopTask->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    l += BEncConsLen (b, l);

    l += BEncTag4 (b, CNTX, CONS, 72108);
      break;

  } // end switch
  return l;
} // BODYPKTS::BEncContent


void BODYPKTS::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnLen elmtLen1;
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 71101):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -187);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = reqLBMasterHeartBeatCid;
      reqLBMasterHeartBeat = new ReqLBMasterHeartBeat;
        reqLBMasterHeartBeat->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 71102):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -188);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = rspLBMasterHeartBeatCid;
      rspLBMasterHeartBeat = new RspLBMasterHeartBeat;
        rspLBMasterHeartBeat->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 71111):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -189);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = reqLBMasterAddTaskCid;
      reqLBMasterAddTask = new ReqLBMasterAddTask;
        reqLBMasterAddTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 71112):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -190);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = rspLBMasterAddTaskCid;
      rspLBMasterAddTask = new RspLBMasterAddTask;
        rspLBMasterAddTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 71113):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -191);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = reqLBMasterDoTaskCid;
      reqLBMasterDoTask = new ReqLBMasterDoTask;
        reqLBMasterDoTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 71114):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -192);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = rspLBMasterDoTaskCid;
      rspLBMasterDoTask = new RspLBMasterDoTask;
        rspLBMasterDoTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 72101):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -193);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = reqLBWorkerHeartBeatCid;
      reqLBWorkerHeartBeat = new ReqLBWorkerHeartBeat;
        reqLBWorkerHeartBeat->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 72102):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -194);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = rspLBWorkerHeartBeatCid;
      rspLBWorkerHeartBeat = new RspLBWorkerHeartBeat;
        rspLBWorkerHeartBeat->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 72103):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -195);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = reqLBWorkerQueryTaskCid;
      reqLBWorkerQueryTask = new ReqLBWorkerQueryTask;
        reqLBWorkerQueryTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 72104):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -196);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = rspLBWorkerQueryTaskCid;
      rspLBWorkerQueryTask = new RspLBWorkerQueryTask;
        rspLBWorkerQueryTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 72105):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -197);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = reqLBWorkerSetTaskCid;
      reqLBWorkerSetTask = new ReqLBWorkerSetTask;
        reqLBWorkerSetTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 72106):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -198);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = rspLBWorkerSetTaskCid;
      rspLBWorkerSetTask = new RspLBWorkerSetTask;
        rspLBWorkerSetTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 72107):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -199);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = reqLBWorkerStopTaskCid;
      reqLBWorkerStopTask = new ReqLBWorkerStopTask;
        reqLBWorkerStopTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 72108):
      tag = BDecTag (b, bytesDecoded, env);
      if (tag != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
      {
         Asn1Error << "Unexpected Tag" << endl;
         longjmp (env, -200);
      }

      elmtLen1 = BDecLen (b, bytesDecoded, env);
      choiceId = rspLBWorkerStopTaskCid;
      rspLBWorkerStopTask = new RspLBWorkerStopTask;
        rspLBWorkerStopTask->BDecContent (b, tag, elmtLen1, bytesDecoded, env);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << endl;
      longjmp (env, -201);
      break;
  } // end switch
} // BODYPKTS::BDecContent


AsnLen BODYPKTS::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void BODYPKTS::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

int BODYPKTS::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int BODYPKTS::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void BODYPKTS::Print (ostream &os) const
{
  switch (choiceId)
  {
    case reqLBMasterHeartBeatCid:
      if (reqLBMasterHeartBeat)
        os << *reqLBMasterHeartBeat;
      else
        os << "-- void3 --\n";
      break;

    case rspLBMasterHeartBeatCid:
      if (rspLBMasterHeartBeat)
        os << *rspLBMasterHeartBeat;
      else
        os << "-- void3 --\n";
      break;

    case reqLBMasterAddTaskCid:
      if (reqLBMasterAddTask)
        os << *reqLBMasterAddTask;
      else
        os << "-- void3 --\n";
      break;

    case rspLBMasterAddTaskCid:
      if (rspLBMasterAddTask)
        os << *rspLBMasterAddTask;
      else
        os << "-- void3 --\n";
      break;

    case reqLBMasterDoTaskCid:
      if (reqLBMasterDoTask)
        os << *reqLBMasterDoTask;
      else
        os << "-- void3 --\n";
      break;

    case rspLBMasterDoTaskCid:
      if (rspLBMasterDoTask)
        os << *rspLBMasterDoTask;
      else
        os << "-- void3 --\n";
      break;

    case reqLBWorkerHeartBeatCid:
      if (reqLBWorkerHeartBeat)
        os << *reqLBWorkerHeartBeat;
      else
        os << "-- void3 --\n";
      break;

    case rspLBWorkerHeartBeatCid:
      if (rspLBWorkerHeartBeat)
        os << *rspLBWorkerHeartBeat;
      else
        os << "-- void3 --\n";
      break;

    case reqLBWorkerQueryTaskCid:
      if (reqLBWorkerQueryTask)
        os << *reqLBWorkerQueryTask;
      else
        os << "-- void3 --\n";
      break;

    case rspLBWorkerQueryTaskCid:
      if (rspLBWorkerQueryTask)
        os << *rspLBWorkerQueryTask;
      else
        os << "-- void3 --\n";
      break;

    case reqLBWorkerSetTaskCid:
      if (reqLBWorkerSetTask)
        os << *reqLBWorkerSetTask;
      else
        os << "-- void3 --\n";
      break;

    case rspLBWorkerSetTaskCid:
      if (rspLBWorkerSetTask)
        os << *rspLBWorkerSetTask;
      else
        os << "-- void3 --\n";
      break;

    case reqLBWorkerStopTaskCid:
      if (reqLBWorkerStopTask)
        os << *reqLBWorkerStopTask;
      else
        os << "-- void3 --\n";
      break;

    case rspLBWorkerStopTaskCid:
      if (rspLBWorkerStopTask)
        os << *rspLBWorkerStopTask;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
} // BODYPKTS::Print

LotteryBonsMessage::LotteryBonsMessage()
{
#if TCL
  body = new BODYPKTS;
#else
  body = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

LotteryBonsMessage::LotteryBonsMessage (const LotteryBonsMessage &)
{
  Asn1Error << "use of incompletely defined LotteryBonsMessage::LotteryBonsMessage (const LotteryBonsMessage &)" << endl;
  abort();
}

LotteryBonsMessage::~LotteryBonsMessage()
{
  delete body;
}

AsnType *LotteryBonsMessage::Clone() const
{
  return new LotteryBonsMessage;
}

#if SNACC_DEEP_COPY
LotteryBonsMessage &LotteryBonsMessage::operator = (const LotteryBonsMessage &that)
#else // SNACC_DEEP_COPY
LotteryBonsMessage &LotteryBonsMessage::operator = (const LotteryBonsMessage &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    iVer = that.iVer;
    iBirthsec = that.iBirthsec;
    iBirthusec = that.iBirthusec;
    iReserved = that.iReserved;
    iSeq = that.iSeq;
    sExtBlob = that.sExtBlob;
    if (that.body)
    {
      if (!body)
        body = new BODYPKTS;
      *body = *that.body;
    }
    else
    {
      delete body;
      body = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined LotteryBonsMessage &LotteryBonsMessage::operator = (const LotteryBonsMessage &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
LotteryBonsMessage::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

    l = body->BEncContent (b);
    totalLen += l;

    l = sExtBlob.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = iSeq.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = iReserved.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = iBirthusec.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = iBirthsec.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = iVer.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // LotteryBonsMessage::BEncContent


void LotteryBonsMessage::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iVer.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -202);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iBirthsec.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -203);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iBirthusec.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -204);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iReserved.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -205);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    iSeq.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -206);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    sExtBlob.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -207);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 71101))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 71102))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 71111))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 71112))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 71113))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 71114))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 72101))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 72102))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 72103))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 72104))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 72105))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 72106))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 72107))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 72108)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    body = new BODYPKTS;
    body->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    longjmp (env, -208);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    longjmp (env, -209);
  }
  else
    return;
} // LotteryBonsMessage::BDecContent

AsnLen LotteryBonsMessage::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void LotteryBonsMessage::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "LotteryBonsMessage::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -210);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

int LotteryBonsMessage::BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded)
{
    bytesEncoded = BEnc (b);
    return !b.WriteError();
}

int LotteryBonsMessage::BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded)
{
    ENV_TYPE env;
    int val;

    bytesDecoded = 0;
    if ((val = setjmp (env)) == 0)
    {
         BDec (b, bytesDecoded, env);
         return !b.ReadError();
    }
    else
        return false;
}

void LotteryBonsMessage::Print (ostream &os) const
{
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "iVer ";
    os << iVer;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "iBirthsec ";
    os << iBirthsec;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "iBirthusec ";
    os << iBirthusec;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "iReserved ";
    os << iReserved;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "iSeq ";
    os << iSeq;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "sExtBlob ";
    os << sExtBlob;
    os << "," << endl;
  }

  if (NOT_NULL (body))
  {
    Indent (os, indentG);
    os << "body ";
    os << *body;
  }
  else
  {
    Indent (os, indentG);
    os << "body ";
    os << "-- void --";
    os << endl;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
} // LotteryBonsMessage::Print


AsnType *LBStringList::Clone() const
{
  return new LBStringList;
}

AsnLen LBStringList::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void LBStringList::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "LBStringList::BDec: ERROR - wrong tag" << endl;
    longjmp (env, -211);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

LBStringList::LBStringList (const LBStringList &)
{
  Asn1Error << "use of incompletely defined LBStringList::LBStringList (const LBStringList &)" << endl;
  abort();
}

LBStringList::~LBStringList()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
LBStringList &LBStringList::operator = (const LBStringList &that)
#else // SNACC_DEEP_COPY
LBStringList &LBStringList::operator = (const LBStringList &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined LBStringList &LBStringList::operator = (const LBStringList &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void LBStringList::Print (ostream &os) const
{
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
} // Print


void  LBStringList::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // LBStringList::SetCurrElmt


unsigned long int  LBStringList::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // LBStringList::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
AsnOcts *LBStringList::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new AsnOcts;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // LBStringList::Append


// alloc new list elmt, put at begining of list
//  and return the component type
AsnOcts  *LBStringList::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // LBStringList::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
AsnOcts  *LBStringList::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // LBStringList::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
AsnOcts *LBStringList::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // LBStringList::InsertAfter


LBStringList  &LBStringList::AppendCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


LBStringList  &LBStringList::PrependCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // LBStringList::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
LBStringList &LBStringList::InsertBeforeAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // LBStringList::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
LBStringList  &LBStringList::InsertAfterAndCopy (AsnOcts &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new AsnOcts;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // LBStringList::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void LBStringList::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen LBStringList::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncDefLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // LBStringList::BEncContent


void  LBStringList::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnOcts *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
         && (tag1 != MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            longjmp (env, -212);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // LBStringList::BDecContent


