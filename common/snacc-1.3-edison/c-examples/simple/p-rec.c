/*
 *    p-rec.c
 *
 *    "P-REC" ASN.1 module encode/decode/print/free C src.
 *
 *    This file was generated by snacc on Wed Sep  5 14:26:27 2007
 *
 *    UBC snacc written by Mike Sample
 *
 *    NOTE: This is a machine generated file - editing not recommended
 */



#include "asn-incl.h"
#include "p-rec.h"


AsnLen
BEncNameContent PARAMS ((b, v),
BUF_TYPE b _AND_
Name *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncIA5StringContent (b, (&v->familyName));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 22);

    totalLen += itemLen;

    itemLen = BEncIA5StringContent (b, (&v->initial));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 22);

    totalLen += itemLen;

    itemLen = BEncIA5StringContent (b, (&v->givenName));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 22);

    totalLen += itemLen;

    return totalLen;

}  /* BEncNameContent */

void
BDecNameContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Name *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, IA5STRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, IA5STRING_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecIA5StringContent (b, tagId1, elmtLen1, (&v->givenName), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -100);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, IA5STRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, IA5STRING_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecIA5StringContent (b, tagId1, elmtLen1, (&v->initial), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -101);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, IA5STRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, IA5STRING_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecIA5StringContent (b, tagId1, elmtLen1, (&v->familyName), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -102);
    }
    else
        longjmp (env, -103);


    if (!seqDone)
        longjmp (env, -104);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNameContent */

void
PrintName PARAMS ((f, v, indent),
FILE* f _AND_
Name *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"givenName ");
    PrintIA5String (f, (&v->givenName), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"initial ");
    PrintIA5String (f, (&v->initial), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"familyName ");
    PrintIA5String (f, (&v->familyName), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintName */

void
FreeName PARAMS ((v),
Name *v)
{

    if (v == NULL)
        return;
    FreeIA5String ((&v->givenName));

    FreeIA5String ((&v->initial));

    FreeIA5String ((&v->familyName));

}  /* FreeName */




AsnLen BEncDate PARAMS ((b, v),
BUF_TYPE b _AND_
Date *v)
{
    AsnLen l;
    l = BEncDateContent (b, v);
    l += BEncDefLen (b, l);
    l += BEncTag1 (b, APPL, PRIM, 3);
    return l;
} /* BEncDate */

void BDecDate PARAMS ((b, result, bytesDecoded, env),
BUF_TYPE b _AND_
Date *result _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    AsnTag tag;
    AsnLen elmtLen1;

    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (APPL, PRIM, 3))&&
        (tag != MAKE_TAG_ID (APPL, CONS, 3)))
    {
        Asn1Error ("BDecDate: ERROR - wrong tag\n");
        longjmp (env, -105);
    }
    elmtLen1 = BDecLen (b, bytesDecoded, env);
    BDecDateContent (b, tag, elmtLen1, result, bytesDecoded, env);
}  /* BDecDate */

AsnLen
BEncChildInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChildInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncDateContent (b, (&v->dateOfBirth));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, PRIM, 3);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 0);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncNameContent (b, (v->name));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 1);

    totalLen += itemLen;

    return totalLen;

}  /* BEncChildInformationContent */

void
BDecChildInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChildInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (APPL, CONS, 1):
    (v->name) = (Name*) Asn1Alloc (sizeof (Name));
    CheckAsn1Alloc ((v->name), env);
    BDecNameContent (b, tagId1, elmtLen1, (v->name), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 0):
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
if ((tagId2 != MAKE_TAG_ID (APPL, PRIM, 3)) &&
   (tagId2 != MAKE_TAG_ID (APPL, CONS, 3)))
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -106);
    }

elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecDateContent (b, tagId2, elmtLen2, (&v->dateOfBirth), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

    default:
        Asn1Error ("BDecChildInformationContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -107);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecChildInformationContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -108);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChildInformationContent */

void
PrintChildInformation PARAMS ((f, v, indent),
FILE* f _AND_
ChildInformation *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SET --\n");

    Indent (f, indent + stdIndentG);
    PrintName (f, (v->name), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"dateOfBirth ");
    PrintDate (f, (&v->dateOfBirth), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChildInformation */

void
FreeChildInformation PARAMS ((v),
ChildInformation *v)
{

    if (v == NULL)
        return;
    FreeName ((v->name));
    Asn1Free ((v->name));

    FreeDate ((&v->dateOfBirth));

}  /* FreeChildInformation */




AsnLen
BEncPersonnelRecordSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
PersonnelRecordSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncChildInformationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 17);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncPersonnelRecordSeqOfContent */

void
BDecPersonnelRecordSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
PersonnelRecordSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ChildInformation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ChildInformation**) AsnListAppend (v);
    (*tmpVar) = (ChildInformation*) Asn1Alloc (sizeof (ChildInformation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecChildInformationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -109);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecPersonnelRecordSeqOfContent */

void
PrintPersonnelRecordSeqOf PARAMS ((f, v, indent),
FILE* f _AND_
PersonnelRecordSeqOf *v _AND_
unsigned short int indent)
{
    ChildInformation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintChildInformation (f, tmp, indent + stdIndentG);
        if (tmp != (ChildInformation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintPersonnelRecordSeqOf */

void
FreePersonnelRecordSeqOf PARAMS ((v),
PersonnelRecordSeqOf *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeChildInformation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreePersonnelRecordSeqOf */




AsnLen BEncPersonnelRecord PARAMS ((b, v),
BUF_TYPE b _AND_
PersonnelRecord *v)
{
    AsnLen l;
    BEncEocIfNec (b);
    l = BEncPersonnelRecordContent (b, v);
    l += BEncConsLen (b, l);
    l += BEncTag1 (b, APPL, CONS, 0);
    return l;
} /* BEncPersonnelRecord */

void BDecPersonnelRecord PARAMS ((b, result, bytesDecoded, env),
BUF_TYPE b _AND_
PersonnelRecord *result _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    AsnTag tag;
    AsnLen elmtLen1;

    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (APPL, CONS, 0)))
    {
        Asn1Error ("BDecPersonnelRecord: ERROR - wrong tag\n");
        longjmp (env, -110);
    }
    elmtLen1 = BDecLen (b, bytesDecoded, env);
    BDecPersonnelRecordContent (b, tag, elmtLen1, result, bytesDecoded, env);
}  /* BDecPersonnelRecord */

AsnLen
BEncPersonnelRecordContent PARAMS ((b, v),
BUF_TYPE b _AND_
PersonnelRecord *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->children)))
    {
    BEncEocIfNec (b);
    itemLen = BEncPersonnelRecordSeqOfContent (b, (v->children));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 3);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    BEncEocIfNec (b);
    itemLen = BEncNameContent (b, (v->nameOfSpouse));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 1);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 2);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncDateContent (b, (&v->dateOfHire));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, PRIM, 3);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 1);

    totalLen += itemLen;

    itemLen = BEncEmployeeNumberContent (b, (&v->employeeNumber));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 128);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncIA5StringContent (b, (&v->title));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 22);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 0);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncNameContent (b, (v->name));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 1);

    totalLen += itemLen;

    return totalLen;

}  /* BEncPersonnelRecordContent */

void
BDecPersonnelRecordContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
PersonnelRecord *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (APPL, CONS, 1):
    (v->name) = (Name*) Asn1Alloc (sizeof (Name));
    CheckAsn1Alloc ((v->name), env);
    BDecNameContent (b, tagId1, elmtLen1, (v->name), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 0):
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
if ((tagId2 != MAKE_TAG_ID (UNIV, PRIM, IA5STRING_TAG_CODE)) &&
   (tagId2 != MAKE_TAG_ID (UNIV, CONS, IA5STRING_TAG_CODE)))
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -111);
    }

elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecIA5StringContent (b, tagId2, elmtLen2, (&v->title), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (APPL, PRIM, 128):
    BDecEmployeeNumberContent (b, tagId1, elmtLen1, (&v->employeeNumber), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 1):
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
if ((tagId2 != MAKE_TAG_ID (APPL, PRIM, 3)) &&
   (tagId2 != MAKE_TAG_ID (APPL, CONS, 3)))
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -112);
    }

elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecDateContent (b, tagId2, elmtLen2, (&v->dateOfHire), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 2):
if (BDecTag (b, &totalElmtsLen1, env) != MAKE_TAG_ID (APPL, CONS, 1))
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -113);
    }

elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    (v->nameOfSpouse) = (Name*) Asn1Alloc (sizeof (Name));
    CheckAsn1Alloc ((v->nameOfSpouse), env);
    BDecNameContent (b, tagId2, elmtLen2, (v->nameOfSpouse), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 3):
    (v->children) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->children), env);
    BDecPersonnelRecordSeqOfContent (b, tagId1, elmtLen1, (v->children), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecPersonnelRecordContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -114);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 5)
    {
        Asn1Error ("BDecPersonnelRecordContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -115);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecPersonnelRecordContent */

void
PrintPersonnelRecord PARAMS ((f, v, indent),
FILE* f _AND_
PersonnelRecord *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SET --\n");

    Indent (f, indent + stdIndentG);
    PrintName (f, (v->name), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"title ");
    PrintIA5String (f, (&v->title), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    PrintEmployeeNumber (f, (&v->employeeNumber), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"dateOfHire ");
    PrintDate (f, (&v->dateOfHire), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"nameOfSpouse ");
    PrintName (f, (v->nameOfSpouse), indent + stdIndentG);
    if (NOT_NULL ((v->children)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"children ");
    PrintPersonnelRecordSeqOf (f, (v->children), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintPersonnelRecord */

void
FreePersonnelRecord PARAMS ((v),
PersonnelRecord *v)
{

    if (v == NULL)
        return;
    FreeName ((v->name));
    Asn1Free ((v->name));

    FreeIA5String ((&v->title));

    FreeEmployeeNumber ((&v->employeeNumber));

    FreeDate ((&v->dateOfHire));

    FreeName ((v->nameOfSpouse));
    Asn1Free ((v->nameOfSpouse));

    if (NOT_NULL ((v->children)))
    {
    FreePersonnelRecordSeqOf ((v->children));
    Asn1Free ((v->children));
    }

}  /* FreePersonnelRecord */




